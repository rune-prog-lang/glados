## Summary of Changes

- Implemented proper handling of floating-point values in the x86_64 backend code generator while preserving existing integer and pointer behavior.
- Adjusted the parameter-passing, call, return, and arithmetic emission logic to use SSE (`xmm`) registers and float-specific instructions for `IRF32`/`IRF64`.
- Kept the integer and pointer code paths unchanged so existing behavior and tests remain valid.

## Detailed Changes

### File: `src/Rune/Backend/X86_64/Codegen.hs`

- Updated imports:
  - Added import of `x86_64FloatArgsRegisters` from `Rune.Backend.X86_64.Registers` so the backend can assign float arguments to `xmm` registers following the System V ABI.
  - Added import of `getOperandType` from `Rune.IR.IRHelpers` so the backend can detect operand types at call/return emission time.
  - Commented out the now-unused `Data.Maybe (mapMaybe)` import to satisfy `-Werror=unused-imports`.

- `emitParameters`:
  - Replaced the previous `mapMaybe/emitParam`-based implementation, which treated all parameters as integer/pointer values and only used general-purpose registers, with an explicit fold that tracks both integer and float argument indices.
  - New behavior:
    - For `IRF32`/`IRF64` parameters, values are assumed to arrive in `xmmN` registers (via the calling convention) and are stored into the appropriate stack locations using `movss`/`movsd` with the correct size specifiers.
    - For non-float parameters, the existing `storeReg` logic is reused, writing values from `x86_64ArgsRegisters` into the stack frame.
  - The old implementation was left commented out immediately below the new code as required by `AGENTS.md`.

- `emitCall` and new `setupCallArgs`:
  - Reworked `emitCall` so that argument setup is delegated to a new helper `setupCallArgs` instead of always zipping arguments with `x86_64ArgsRegisters`.
  - `setupCallArgs`:
    - Uses `getOperandType` to determine each argumentâ€™s `IRType`.
    - For float arguments (`IRF32`/`IRF64`), loads operands into `x86_64FloatArgsRegisters` (`xmmN`) using the new `loadFloatOperand` helper.
    - For non-floats, preserves the previous behavior by using `loadRegWithExt` and the integer argument registers.
    - Falls back to a best-effort `rax` load when the type cannot be determined.
  - The previous `emitCall` implementation is preserved as commented-out code.

- `saveCallResult`:
  - Extended to handle float return types:
    - For `IRF32`, the return value is stored from `xmm0` to the destination stack slot using `movss dword [...]`.
    - For `IRF64`, it uses `movsd qword [...]`.
  - Non-float return types still use the existing `storeReg`/`rax` path.
  - Original `saveCallResult` is commented out under the new implementation.

- `emitRet`:
  - Updated to return float values correctly:
    - When `getOperandType` reports a float type, the value is loaded into `xmm0` via `loadFloatOperand` and control jumps to the function epilogue label.
    - For other types, the old behavior of loading into `rax` is retained.
  - The original implementation is left commented out.

- `emitBinaryOp` and new `emitFloatBinaryOp`:
  - `emitBinaryOp` now distinguishes between float and non-float operations:
    - For non-float types, the original GPR-based code path is reused unchanged.
    - For float types, it delegates to `emitFloatBinaryOp`.
  - `emitFloatBinaryOp`:
    - Loads left and right operands into `xmm0` and `xmm1` using `loadFloatOperand`.
    - Chooses appropriate SSE scalar instructions:
      - `IRF32`: `addss`, `subss`, `mulss`
      - `IRF64`: `addsd`, `subsd`, `mulsd`
    - Stores the result back to the destination stack slot with `movss`/`movsd`, using the correct size and addressing.
    - For unsupported combinations, emits a safe placeholder instruction and an explanatory comment.
  - The old, integer-only `emitBinaryOp` definition is retained in commented form below the new implementation.

- New helper `loadFloatOperand`:
  - Added to load `IRF32` and `IRF64` temporaries and parameters from the stack into a given `xmm` register using `movss`/`movsd`.
  - For unsupported operands, it emits a warning comment and zeros the register with `xorps`.

- New helper `isFloatType`:
  - Added a small backend-local predicate to test whether an `IRType` is `IRF32` or `IRF64`, used by several of the updated functions to branch between float and integer logic.

Throughout the changes in `Codegen.hs`, each modification follows the `AGENTS.md` policy:

- A brief `-- explanation` comment is placed above each modified block.
- New code appears immediately below the explanation.
- The old code is preserved and commented out under the new code.

## Tests

- After making the changes, the following commands were executed:
  - `make`
    - Result: Succeeded. The project builds with the updated x86_64 backend.
  - `make tests`
    - Result: All tests passed.
    - Notable confirmations from the test output:
      - Existing integer, pointer, control-flow, and memory backend tests still pass.
      - Float comparison tests (which already exercised `ucomiss`/`ucomisd`) continue to pass, confirming that the new float helpers did not break comparison behavior.

There were no test failures, so no corrective changes or additional unit tests were required beyond the core backend modifications.

## Commit Script

- As required by `AGENTS.md`, an attempt was made to execute:
  - `script/normed_commit.sh feat backend "Add SSE-based float support to x86_64 codegen"`
- Result:
  - The command failed with: `No such file or directory`
  - This indicates that `script/normed_commit.sh` does not exist in the repository.
- Because the script is missing, no automated normalized commit could be created. All code changes are present in the working tree and have been validated by `make` and `make tests`.

